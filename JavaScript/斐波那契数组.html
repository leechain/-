<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>斐波那契数组算法</title>
</head>

<body>
    <!-- 斐波那契数组：任意相邻两个数字相加等于下一个数字，比如：1，1，2，3，5，8，13，21，34......（背景为大兔子生小兔子的故事） -->
    <script type="text/javascript">
        // 法一：二叉递归算法，时间复杂度为O(2^n)（效率低下）
        function Fibonacci(n) {
            var arr = [];
            if (n == 0) {
                return 0;
            } else if (n == 1) {
                return 1;
            } else if (n > 1) {
                return Fibonacci(n - 1) + Fibonacci(n - 2);
            } else {
                return 0;
            }
        }
        // alert(Fibonacci(8)); //21

        //优化递推算法， 时间复杂度为o(n)，空间复杂度优化为o(1)。
        //分析：在计算f(n)时我们只需要 f(n-1), f(n-2)，数组index在n-2之前的元素已经没有存在的必要。
        function Fibonacci1(n) {
            var n1 = 0,
                n2 = 1;
            var temp;
            for (var i = 2; i < n; i++) {
                temp = n1;
                n1 = n2;
                n2 = n2 + temp;
            }
            return n2;
        }
        // alert(Fibonacci(8)); //21

        //法二：迭代法，效率为O(N)
        function Fibonacci2(n) {
            if (n <= 0) {
                return 0;
            }
            var x = 0,
                y = 1;
            for (var i = 1; i < n; i++) {
                y = x + y;
                x = y - x;
            }
            return y;
        }
        // alert(Fibonacci2(100)); //354224848179262000000



        //法三：公式法，需要先推倒公式
        function Fibonacci3(n) {
            var z = Math.sqrt(5.0);
            var x = (1 + z) / 2;
            var y = (1 - z) / 2;
            return (Math.pow(x, n) - Math.pow(y, n)) / z;
        }
        // alert(Fibonacci3(100)); //354224848179261800000

        //法四：二分法，效率最高，为O(log(N))
        function Fibonacci4(n) {
            //比较复杂，水平有限，暂时不写
        }
    </script>
</body>

</html>